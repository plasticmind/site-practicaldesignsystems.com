  <script>

    {% include "partials/testimonial-list.js.njk" %}

    // Enable debug mode
    const debug = false;

    // Check if the user prefers reduced motion
    const isReduced = window.matchMedia(`(prefers-reduced-motion: reduce)`) === true || window.matchMedia(`(prefers-reduced-motion: reduce)`).matches === true;

    // Check if the browser supports CSS blend modes
    const supportsBlendMode = ('CSS' in window && 'supports' in window.CSS) && window.CSS.supports('mix-blend-mode', 'multiply');

    // Select the SVG elements (shapes) we want to animate
    const logo = document.querySelector('.c-logo--icon');
    const shapes = document.querySelectorAll('.c-logo--icon .c-logo__shape');
    const shape_outlines = document.querySelectorAll('.c-logo--icon .c-logo__shape--outline');
    const shape1 = document.querySelector('.c-logo--icon .c-logo__shape--blue');
    const shape2 = document.querySelector('.c-logo--icon .c-logo__shape--green');
    const shape3 = document.querySelector('.c-logo--icon .c-logo__shape--red');


    // Define starting positions for each shape
    // Todo: Make these dynamic based on the SVG's viewBox
    const s1_start = 75;
    const s2_start = -75;
    const s3_start = 22;

    // Define a starting opacity
    const opacity_start = 0;

    // Define a scroll threshold (in pixels) where the animation should stop (only if logo exists)
    const scrollThreshold = logo ? logo.offsetTop + 50 : 0;
    console.log(logo.offsetTop);

    // Define debounce duration (in milliseconds)
    const debounceDuration = 2;

    // Variable to store the debounce timer
    let debounceTimer;

    function prepareAnimation() {
        // Set the initial opacity and position of the shapes
        if (shapes !== null) {
            shapes.forEach((shape) => {
                shape.style.cssText = 'opacity:' + opacity_start + ';';
            });
            shape1.setAttribute('transform', 'translate(' + s1_start + ', 0)');
            shape2.setAttribute('transform', 'translate(' + s2_start + ', 0)');
            shape3.setAttribute('transform', 'translate(' + s3_start + ', 0)');
        }
    }

    // Ease our animation
    function easeInOutBack(x) {
        const c1 = 1.70158;
        const c2 = c1 * 1.525;

        return x < 0.5 ?
            (Math.pow(2 * x, 2) * ((c2 + 1) * 2 * x - c2)) / 2 :
            (Math.pow(2 * x - 2, 2) * ((c2 + 1) * (x * 2 - 2) + c2) + 2) / 2;
    }

    // Function to handle the scroll event
    function handleScroll() {

        // Get the current scroll position
        const scrollTop = window.pageYOffset || document.documentElement.scrollTop;

        // Calculate the relative scroll position (0 to 1) based on the scroll threshold
        const relativeScroll = Math.min(scrollTop / scrollThreshold, 1);

        // Apply easing function to the relative scroll position
        const easedScroll = easeInOutBack(relativeScroll);

        // Apply translation to the SVG elements based on the scroll position

        shape1pos = s1_start - (easedScroll * s1_start);
        shape2pos = s2_start - (easedScroll * s2_start);
        shape3pos = s3_start - (easedScroll * s3_start);
        shape_opacity = opacity_start + (easedScroll * (1 - opacity_start));

        // outline opacity should start at 1 and end at 0
        outline_opacity = 1 - (easedScroll * (1 - opacity_start));
        

        shapes.forEach((shape) => {
            shape.style.cssText = 'opacity:' + shape_opacity + ';';
        });
        shape_outlines.forEach((outline) => {
            outline.style.cssText = 'opacity:' + outline_opacity + ';';
        });
        shape1.setAttribute('transform', 'translate(' + shape1pos + ', 0)');
        shape2.setAttribute('transform', 'translate(' + shape2pos + ', 0)');
        shape3.setAttribute('transform', 'translate(' + shape3pos + ', 0)');
    }

    // Debounced scroll event listener
    function debounceScroll() {
        // Clear any existing debounce timer
        clearTimeout(debounceTimer);

        // Set a new debounce timer
        debounceTimer = setTimeout(handleScroll, debounceDuration);
    }

    // Choose two random testimonials without repeating
    const randomIndexes = [];
    while (randomIndexes.length < 2) {
        const index = Math.floor(Math.random() * testimonials.length);
        if (!randomIndexes.includes(index)) {
            randomIndexes.push(index);
        }
    }

    // Get the testimonials and update the HTML
    const testimonialElements = document.querySelectorAll(".c-testimonial");
    if (testimonialElements.length !== null) {
        testimonialElements.forEach((element, i) => {
            const testimonial = testimonials[randomIndexes[i]];
            const testimonialText = testimonial.text;
            const testimonialAuthor = testimonial.author;
            element.querySelector(".c-testimonial__text").textContent = `"${testimonialText}"`;
            element.querySelector(".c-testimonial__author").textContent = `- ${testimonialAuthor}`;
            // Create anchor tag if link is provided
            if (testimonial.link) {
                const testimonialLink = testimonial.link;
                const testimonialLinkElement = document.createElement("a");
                testimonialLinkElement.setAttribute("href", testimonialLink);
                testimonialLinkElement.setAttribute("target", "_blank");
                testimonialLinkElement.setAttribute("rel", "noopener noreferrer");
                testimonialLinkElement.setAttribute("title", "More about " + testimonialAuthor + " â†’");
                testimonialLinkElement.textContent = testimonialAuthor;
                element.querySelector(".c-testimonial__author").innerHTML = `- `;
                element.querySelector(".c-testimonial__author").appendChild(testimonialLinkElement);
            }
        });
    }

    // Fire confetti when successful newsletter submission

    const observer = new MutationObserver(function (mutations) {
        mutations.forEach(function (mutation) {
            if (mutation.addedNodes.length) {
                for (let i = 0; i < mutation.addedNodes.length; i++) {
                    if (mutation.addedNodes[i].dataset.element === "success") {
                        confetti();
				        observer.disconnect();
                    }
                }
            }
        });
    });
    
    if (document.querySelector('.js-subscribe-form')) {
        observer.observe(document.querySelector('.js-subscribe-form'), {
            childList: true,
            subtree: true
        });
    }

    // Thanks, Stephan! https://stephanwagner.me/auto-resizing-textarea-with-vanilla-javascript
    function addAutoResize() {
        document.querySelectorAll('[data-autoresize]').forEach(function (element) {
            element.style.boxSizing = 'border-box';
            var offset = element.offsetHeight - element.clientHeight;
            element.addEventListener('input', function (event) {
            event.target.style.height = 'auto';
            event.target.style.height = event.target.scrollHeight + offset + 'px';
            });
            element.removeAttribute('data-autoresize');
        });
    }

    // After DOM is loaded
    document.addEventListener('DOMContentLoaded', function () {

        // == Auto-resize textarea elements
        addAutoResize();

        // == Add the debounced scroll event listener to the window
        if (supportsBlendMode === true && shape1 !== null) {
            prepareAnimation();
            window.addEventListener('scroll', debounceScroll);
        }

    });

    // Debug mode
    if (debug === true) {

        const debug_holder = document.createElement('div');

        debug_holder.classList.add('c-debug');

        const debugTitle = document.createElement('pre');
        debugTitle.innerHTML = '<b>Debug</b>';
        debug_holder.appendChild(debugTitle);

        const debugSupportsBlendMode = document.createElement('pre');
        debugSupportsBlendMode.innerHTML = 'Supports Blend Mode: ' + supportsBlendMode;
        debug_holder.appendChild(debugSupportsBlendMode);
        console.log("supportsBlendMode: " + supportsBlendMode);

        const debugIsReduced = document.createElement('pre');
        debugIsReduced.innerHTML = 'Is Reduced: ' + isReduced;
        debug_holder.appendChild(debugIsReduced);
        console.log("isReduced: " + isReduced);

        const debugScrollThreshold = document.createElement('pre');
        debugScrollThreshold.innerHTML = 'Scroll Threshold: ' + scrollThreshold;
        debug_holder.appendChild(debugScrollThreshold);
        console.log("scrollThreshold: " + scrollThreshold);

        document.querySelector('body').appendChild(debug_holder);

    }

  </script>
  <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.5.1/dist/confetti.browser.min.js"></script>
